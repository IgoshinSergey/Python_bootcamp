# Team 00 - Python Bootcamp

## Magical connections

## Contents

1. [Chapter I](#chapter-i) \
    1.1. [General rules](#general-rules)
2. [Chapter II](#chapter-ii) \
    2.1. [Rules of the day](#rules-of-the-day)
3. [Chapter III](#chapter-iii) \
    3.1. [Intro](#intro)
4. [Chapter IV](#chapter-iv) \
    4.1. [Exercise 00: Old Style](#exercise-00-old-style)
5. [Chapter V](#chapter-v) \
    5.1. [Exercise 01: Shortcuts](#exercise-01-shortcuts)
6. [Chapter VI](#chapter-vi) \
    6.1. [Exercise 02: Greatest Magicians](#exercise-02-greatest-magicians)

<h2 id="chapter-i" >Chapter I</h2>
<h2 id="general-rules" >General rules</h2>

- Your scripts should not exit unexpectedly (return an error on valid input). If this happens, your project will be considered non-functional and will receive a 0 in the evaluation.
- We encourage you to create test programs for your project, even though this work doesn't have to be submitted and won't be graded. This will allow you to easily test your work and the work of your peers. You will find these tests particularly useful during your defense. In fact, you are free to use your tests and/or the tests of the peer you are evaluating during your defense.
- Submit your work to your assigned git repository. Only work in the git repository will be graded.

<h2 id="chapter-ii" >Chapter II</h2>
<h2 id="rules-of-the-day" >Rules of the day</h2>

- You should submit `*.py` files and `requirements.txt` if your code uses third-party modules. The image/HTML file generated by EX02 can also be included, but your code should still be able to generate a similar one.
- It is also recommended to write some tests for different cases inside your scripts. To make them run only when the script is executed directly and not imported from somewhere else, you can use the `if __name__ == "__main__":` statement. You can read more about this [here](https://www.geeksforgeeks.org/what-does-the-if-__name__-__main__-do/)
- The work on this day can and should be parallelized. While someone is parsing Wikipedia for EX00, another team member can play around with shortest path algorithms, and someone else can research the image rendering part.
- Inspiration: [Harry Potter and Methods of Rationality](http://www.hpmor.com/), for playing around with graphs you can try [Gephi](https://gephi.org/).

<h2 id="chapter-iii" >Chapter III</h2>
<h2 id="intro" >Intro</h2>


Albus Percival Wulfric Brian Dumbledore sat in his chair and looked at a young boy with a lightning scar on his forehead.

 "So, Harry, you're saying that all Muggles are connected with just [six handshakes](https://en.wikipedia.org/wiki/Six_degrees_of_separation)?"

 "It's not exactly proven, of course," Harry straightened his glasses. "But it's not just for Muggles, it's for everyone!"
 
 "I think that's a pretty bold assumption. Any other examples of these... *graphs* you can give me?"
 
 "One of the largest public encyclopedias in the world is called Wikipedia..."
 
 "It must be a pretty big book! Even a whole series..."

 Harry sighed.

 "It's not a book, it's a website. But the idea is similar to, say, dictionaries — different entities are linked together..."

<h2 id="chapter-iv" >Chapter IV</h2>
<h3 id="ex00">Exercise 00: Old Style</h3>

For the next few minutes, Harry continued to explain to Dumbledore what a 'website' was, but an old wizard was still unsure about the value of a 'book that can't be touched'.

Harry also tried to explain how some people could follow the links from one article to another and then end up wondering how they got to another topic in the first place. This was much easier for Dumbledore to relate to, and he even started talking nostalgically about a time when he got completely lost in a library for a couple of days.

Looks like it was necessary to download some information to illustrate the concept.

-----

You will need to write a script called `cache_wiki.py` whose main purpose will be to download pages from Wikipedia, but the data we are interested in are links in text and "See Also" sections that point to other pages within Wikipedia itself. This means that you don't need to download the content, just save a graph representation as a JSON file `wiki.json`, so that vertices store pages and directed edges are links.

You can choose any Wikipedia article as the default starting point. Also, your code should be able to take the name of an existing article as an argument to use instead of a default one (not necessarily Harry Potter related). So if you run it like this:

`~$ python cache_wiki.py -p 'Erdős number'`

It should start parsing from [this page](https://en.wikipedia.org/wiki/Erd%C5%91s_number).
Note the special symbol encoding in the URL.

The goal is to keep following links (only those leading to other Wikipedia pages, NOT to the outside Internet) to go *at least three pages deep* in each link. This parameter should be configurable using `-d`, so the default value will be `3`. But if the result is too large (>1000 pages), your code should stop processing links. If it is too small (<20 pages), please choose another default start page. Don't forget to keep track of the links that lead to the pages you've already visited. If page A links to page B, and page B links to page A — that is two directed graph edges, not one.

Each page visited by your code should be logged to stdout using the `logging` Python module with the log level set to 'INFO'. 

There are no strict requirements on the format of the JSON file your code produces, but keep in mind that you'll need to work with this file further in future exercises, so you might consider using existing Python graph processing libraries that support reading/writing JSON files.

For extra credit in this exercise, your code can also support storing the graph in a [Neo4J database](https://neo4j.com/download/).

<h2 id="chapter-v" >Chapter V</h2>
<h3 id="ex01">Exercise 01: Shortcuts</h3>

 "I see. But why are Welsh Corgis so close to King Solomon?"

Harry was about to say that he had no idea, but then he noticed the wizard's smiling eyes. 

 "Frankly, I doubt it's the strangest connection," the boy said, "but don't you think, sir, it's..."
 
 "...absolutely fascinating!" the wizard finished. "I think I've underestimated Muggle technology here. Muggle technology here, well done. Anyway, how do we find out how closely two sides are connected?"

Harry thought for a moment. 

 "I suppose we could try to find the shortest path from one side to the other. That's a pretty complicated task with a regular book, but it gets a lot easier on a serialized graph."

-----

Now, you should write a program called `shortest_path.py` that needs to find the *shortest* path length between two pages in your serialized database (if those pages exist):

```
~$ python shortest_path.py --from 'Welsh Corgi' --to 'Solomon'
3
~$ python shortest_path.py --from 'Solomon' --to 'Welsh Corgi' --non-directed
3
```

Note the `--not directed` flag. It means that we treat all links as non-directed or bidirectional, so every edge is treated equally in both directions. In this case, a path exists between *any* two nodes in your serialized graph.

By default (when `--non-directed` is not specified) we only follow the directed edges of the graph. This means that not all pages in the database may be reachable from other pages, especially if they have a small number of inbound links. If the path doesn't exist, your script should print 'path not found'.

The location of the wiki file should be read from the `WIKI_FILE` environment variable. If the database file is not found, the code should print 'database not found'.

Additionally, please add a `-v` flag to enable logging of the found path, like this:

```
~$ python shortest_path.py -v --from 'Welsh Corgi' --to 'Solomon'
'Welsh Corgi' -> 'Dog training' -> 'King Solomon's Ring (book)' -> 'Solomon'
3
```

In this exercise, you should not use an existing implementation of a 'shortest path' algorithm provided by an existing library. Please write your own instead.


<h2 id="chapter-vi" >Chapter VI</h2>
<h3 id="ex01">Exercise 02: Greatest Magicians</h3>

  "Now I can see the connection with the "six handshake" rule you mentioned. Great magicians can be quite popular, right?"

The boy stared at him, trying to understand what was going on in the old wizard's head.

 "Oh, Harry, don't you know the definition of popularity? The more fans you have, the better known you are. Like rock bands."

Dumbledore got up and walked to the entrance of the office. He stopped just before the door and turned back to Harry with a smile.

 "I think all we have to do is visualize the data. Find out who's the biggest, I mean."

Harry raised an eyebrow and looked at the wizard in surprise. It was said quite loudly and it looked like Dumbledore was serious. Find out who is the greatest? Okay, from the graphic's point of view it shouldn't be too hard...

...Draco Malfoy managed to escape being caught eavesdropping. He hid around the corner from the Headmaster's office as Dumbledore left, and now his mind was filled with thoughts of 'greatest wizard'. He decided that the next owl he would send to his father would be about connecting Malfoy Manor to the Internet.

-----

Your next script `render_graph.py` should render a visualization of your page graph (from a file generated in EX00, also read from a `WIKI_FILE` env variable) as a PNG image `wiki_graph.png`, with nodes and edges. You can use any third-party library to do this.

The main rule here is that the size of the node should correspond to the number of incoming connections. The more connections — the bigger the node in the render. This way the "greatest sides" in your dataset will be the best visible ones.

You can get extra points in this task if your script can optionally generate not only a `.png` file, but also a `wiki_graph.html' page that shows an interactive visualization of the same graph. You can use libraries such as [Altair](https://altair-viz.github.io/) or [Bokeh](https://docs.bokeh.org/en/latest/index.html)
to do this.


**Please leave your feedback [here](https://forms.gle/ZmAjM5qJ3uEnADen6).**
